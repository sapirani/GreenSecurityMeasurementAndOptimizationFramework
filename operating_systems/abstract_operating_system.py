import shlex
import subprocess
import threading
from abc import abstractmethod
from threading import Thread
from typing import TextIO, Callable, Optional, Tuple

import pandas as pd
import psutil

from program_parameters import DEFAULT_SCREEN_TURNS_OFF_TIME, DEFAULT_TIME_BEFORE_SLEEP_MODE


class AbstractOSFuncs:
    def init_thread(self):
        """
        probably only needed in Windows
        :return: None
        """
        pass

    def save_battery_capacity(self, f: TextIO):
        """
        Save the full capacity of the device's battery into a file
        :param f: an open file to write capacity into
        """
        pass

    def save_system_information(self, f: TextIO):
        """
        Save general information about the device (such as manufacturer) into a file
        :param f: an open file to write information into
        """
        pass

    def save_physical_memory(self, f: TextIO):
        """
        Save information about the installed memory (such as speed, capacity, etc.) into a file
        :param f: an open file to write information into
        """
        pass

    def save_disk_information(self, f: TextIO):
        """
        Save information about the installed disk (such as manufacturer, size, firmware version, etc.) into a file
        :param f: an open file to write information into
        """
        pass

    def message_box(self, title: str, text: str, style: int) -> bool:
        """
        A GUI prompt for ensuring the user wants to override previous results
        :return: True if the user chose to override previous results, otherwise False is returned
        """
        pass

    @abstractmethod
    def insert_battery_state_to_df(self, battery_df: pd.DataFrame, time_interval: float, battery_percent: int):
        """
        Save to current battery measurement (remaining capacity and voltage consumption) into a dataframe and log results
        :param battery_df: dataframe to save results into
        :param time_interval: time left since scan started
        :param battery_percent: current battery capacity percentage
        (as a fraction relative to the device's total battery capacity)
        """
        pass

    @abstractmethod
    def get_computer_info(self, is_inside_container: bool) -> str:
        """
        :param is_inside_container: True if code is running inside docker container
        :return: a string representing general information about the measured device
        (e.g., hostname, operating system name, etc.)
        """
        pass

    @abstractmethod
    def get_page_faults(self, psutil_process: psutil.Process) -> int:
        """
        :param psutil_process: measured process
        :return: number of page faults generated by the process
        """
        pass

    @staticmethod
    def get_hostname() -> str:
        """
        :return: Device's hostname
        """
        import socket
        return socket.gethostname()

    @staticmethod
    def popen(
            command: str,
            find_child_id_func: Callable[[psutil.Process, bool], Optional[int]],
            should_use_powershell: bool,
            is_posix: bool,
            should_find_child_id: bool = False,
            f_stdout=subprocess.PIPE,
            f_stderr=subprocess.PIPE
    ) -> Tuple[psutil.Process, int]:
        """
        Open a process that runs in the background
        :param command: the command to start the process
        :param find_child_id_func: A function that extracts the child pid from process
        :param should_use_powershell: Whether to start the program as a powershell program or not
        :param is_posix:
        :param should_find_child_id: whether to return pid of the child or the opened process itself
        :param f_stdout: fd for directing the stdout of the opened process
        :param f_stderr: fd for directing the stderr of the opened process
        :return: opened process and pid
        """
        print(command)

        def process_obj_and_pid(command_lst):
            popen_creation_flags = 0 if is_posix else subprocess.CREATE_NEW_PROCESS_GROUP
            p = psutil.Popen(command_lst, stdout=f_stdout, stderr=f_stderr, creationflags=popen_creation_flags)
            pid = p.pid

            if should_use_powershell or should_find_child_id:
                pid = find_child_id_func(p, is_posix)
                print(pid)
                if pid is not None and not should_use_powershell:
                    p = psutil.Process(pid)
            return p, pid

        if should_use_powershell:
            command = ["powershell", "-Command", command]
        else:
            # command = shlex.split(commnd, posix=is_posix)
            command = list(map(lambda s: s.strip('"'), shlex.split(command, posix=is_posix)))

        try:
            return process_obj_and_pid(command)
        except FileNotFoundError as e:
            if command[0] == "python":
                command[0] = "python3"
                return process_obj_and_pid(command)
            else:
                raise e

    def wait_for_thread_termination(self, thread: Thread, done_scanning_event: threading.Event):
        """
        Important - this function should allow the signal handler to strat without blocking interrupts.
        For example, in Windows, performing a simple thread.join() blocks interrupts (so CTRL+C won't stop the program)
        """
        thread.join()

    def wait_for_process_termination(self, process: subprocess.Popen, done_scanning_event: threading.Event) -> int:
        """
        Important - this function should allow the signal handler to strat without blocking interrupts.
        For example, in Windows, performing a simple thread.join() blocks interrupts (so CTRL+C won't stop the program)
        """
        return process.wait()

    @abstractmethod
    def change_power_plan(self, name: str, identifier: str):
        """
        Control device's powerplan (for example, performance mode or power saver)
        """
        pass

    @abstractmethod
    def get_chosen_power_plan_identifier(self) -> str:
        pass

    def get_default_power_plan_name(self) -> str:
        pass

    def get_default_power_plan_identifier(self) -> str:
        pass

    @abstractmethod
    def change_sleep_and_turning_screen_off_settings(self, screen_time: int = DEFAULT_SCREEN_TURNS_OFF_TIME,
                                                     sleep_time: int = DEFAULT_TIME_BEFORE_SLEEP_MODE):
        """
        :param screen_time: time without activity before screen turns off
        :param sleep_time: time without activity before sleep mode is activated
        """
        pass

    def is_posix(self) -> bool:
        pass

    @abstractmethod
    def get_container_total_cpu_usage(self) -> float:
        """
        :return: total cpu consumption inside the docker container
        """
        pass

    @abstractmethod
    def get_container_number_of_cores(self) -> float:
        """
        :return: available number of cores inside the docker container
        """
        pass

    @abstractmethod
    def get_container_total_memory_usage(self) -> tuple[float, float]:
        """
        :return: total memory consumption in bytes and as a percentage from memory size allocated to the docker container
        """
        pass

    @abstractmethod
    def kill_process_gracefully(self, process_pid: int):
        """
        Send a signal to the process to terminate gracefully
        """
        pass
